#!/usr/bin/env node

// Generated by CoffeeScript 1.3.3
(function() {
  var Synk, arg, config, exec, fs, index, options, path, synk, _i, _len, _ref;

  fs = require('fs');

  exec = require('child_process').exec;

  path = require('path');

  try {
    config = require("" + (process.cwd()) + "/synk.json");
  } catch (err) {
    config = false;
  }

  Synk = (function() {

    function Synk(options) {
      var _this = this;
      this.options = options;
      process.stdin.setEncoding('utf8');
      if (!this.options.config_file) {
        process.stdin.resume();
        console.log("\n\n\n\nThere is no synk.json file for the project in " + (process.cwd()) + "\n\nCreate one now?\ntype 'yes' or 'no'");
        process.stdin.once('data', function(input) {
          if (input === 'yes\n') {
            _this.appname = _this.options.appname;
            _this.settings = {
              src: process.cwd(),
              post_upload_command_sequence: []
            };
            _this.prompts = [
              {
                prompt: '\nenter path to .pem file:\n',
                value: 'pem',
                resolve: true
              }, {
                prompt: '\nenter remote dir to synk files to:\n',
                value: 'remote_dir'
              }, {
                prompt: '\nenter username:\n',
                value: 'username'
              }, {
                prompt: '\nenter hostname:\n',
                value: 'hostname'
              }
            ];
            return _this.prompter(0);
          } else {
            return process.exit();
          }
        });
      } else if (this.options.remove_app) {
        process.stdin.resume();
        console.log("\n\nYou sure you want to remove the settings for the app " + this.options.appname + "?\n\ntype 'yes' or 'no'\n\n");
        process.stdin.once('data', function(input) {
          if (input === 'yes\n') {
            return fs.unlink("" + (process.cwd()) + "/synk.json", function(err) {
              if (err) {
                console.log(err);
              } else {
                console.log('done');
              }
              return process.exit();
            });
          } else {
            return process.exit();
          }
        });
      } else {
        this.push();
      }
    }

    Synk.prototype.prompter = function(i) {
      var _this = this;
      console.log(this.prompts[i].prompt);
      return process.stdin.once('data', function(input) {
        var cleaned_input;
        if (_this.prompts[i].resolve) {
          cleaned_input = path.resolve(input.replace('\n', ''));
        } else {
          cleaned_input = input.replace('\n', '');
        }
        _this.settings[_this.prompts[i].value] = cleaned_input;
        i++;
        if (i >= _this.prompts.length) {
          console.log('enter a command that should be run on the server after file upload has compleated, or press enter to skip this.\n');
          return _this.post_upload_command_prompter();
        } else {
          return _this.prompter(i);
        }
      });
    };

    Synk.prototype.post_upload_command_prompter = function() {
      var _this = this;
      return process.stdin.once('data', function(input) {
        var settings_str;
        input = input.replace('\n', '');
        if (input) {
          _this.settings.post_upload_command_sequence.push(input);
          console.log('enter another command to add run, or press enter to finish.');
          return _this.post_upload_command_prompter();
        } else {
          settings_str = JSON.stringify(_this.settings, null, 4);
          console.log("Here are your settings for " + _this.options.appname + ":\n");
          console.log("" + settings_str + "\n to go with them type 'yes'. To enter them again type 'no' \n\n");
          return process.stdin.on('data', function(input) {
            var config_str;
            if (input === 'no\n') {
              return process.exit();
            } else {
              process.stdin.pause();
              _this.options.config_file[_this.appname] = _this.settings;
              config_str = JSON.stringify(_this.settings, null, 4);
              return fs.writeFile('./synk.json', config_str);
            }
          });
        }
      });
    };

    Synk.prototype.push = function() {
      var app, command, scp,
        _this = this;
      app = this.options.config_file;
      command = "rsync -zvr --delete -e \"ssh -i " + app.pem + "\" " + app.src + " " + app.username + "@" + app.hostname + ":" + app.remote_dir;
      scp = exec(command, {
        stdio: 'ignore'
      }, function(err, stdout, stderr) {
        if (err) {
          console.log(err);
          return process.exit(1);
        } else {
          scp.kill();
          return _this.open_ssh();
        }
      });
      return scp.stdout.pipe(process.stdout);
    };

    Synk.prototype.open_ssh = function() {
      var app, command, index, ssh, _i, _j, _len, _len1, _ref, _ref1, _results;
      app = this.options.config_file;
      if (app.post_upload_command_sequence.length) {
        console.log('\n\n############################ FILES SYNK-ED ######################\n\n');
        console.log('now attempting to run the following commands:\n');
        _ref = app.post_upload_command_sequence;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          command = _ref[_i];
          console.log(command + '\n');
        }
        ssh = exec("ssh -t -t -i " + app.pem + " " + app.username + "@" + app.hostname, function(err, stdout, stderr) {
          if (err) {
            console.log(err);
            return process.exit(1);
          } else {
            return console.log('\n\n###################### COMMAND SEQUENCE COMPLEATED ##################\n\ndone');
          }
        });
        ssh.stdout.pipe(process.stdout);
        _ref1 = app.post_upload_command_sequence;
        _results = [];
        for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
          command = _ref1[index];
          ssh.stdin.write("" + command + "\n");
          if (index === (app.post_upload_command_sequence.length - 1) && command !== 'exit') {
            _results.push(ssh.stdin.write('exit\n'));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    return Synk;

  })();

  options = {
    config_file: config
  };

  _ref = process.argv;
  for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
    arg = _ref[index];
    switch (arg) {
      case '-rm':
      case '--remove':
        options.remove_app = true;
        break;
      case '-h':
      case '--help':
        options.show_help = true;
        break;
      case '-c':
      case '--config':
        options.show_config = true;
    }
  }

  if (options.show_config) {
    console.log(JSON.stringify(config, null, 4));
  } else if (options.show_help) {
    console.log("\n\n\nUsage: synk [OPTIONS]\n\nOptions:\n  --remove, -rm            Remove the synk.json config file\n --config, -c             Show synk.json config file\n --help, -h               Show this message\n\n\n");
  } else {
    synk = new Synk(options);
  }

}).call(this);
