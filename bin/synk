#!/usr/bin/env node

// Generated by CoffeeScript 1.3.3
(function() {
  var Synk, appname, arg, conf, config, exec, fs, index, options, path, spawn, synk, _i, _len, _ref;

  fs = require('fs');

  exec = require('child_process').exec;

  spawn = require('child_process').spawn;

  config = require('../config.json');

  path = require('path');

  Synk = (function() {

    function Synk(options) {
      var _this = this;
      this.options = options;
      process.stdin.setEncoding('utf8');
      if (!this.options.config_file[this.options.appname] || this.options["new"]) {
        process.stdin.resume();
        console.log("\n\n\n\nAdd configuration for " + this.options.appname + "? \ntype 'yes' or 'no'");
        process.stdin.once('data', function(input) {
          if (input === 'yes\n') {
            _this.appname = _this.options.appname;
            _this.settings = {
              post_upload_command_sequence: []
            };
            _this.prompts = [
              {
                prompt: '\nenter path to .pem file:\n',
                value: 'pem',
                resolve: true
              }, {
                prompt: '\nenter source dir:\n',
                value: 'src',
                resolve: true
              }, {
                prompt: '\nenter remote dir:\n',
                value: 'remote_dir'
              }, {
                prompt: '\nenter username:\n',
                value: 'username'
              }, {
                prompt: '\nenter hostname:\n',
                value: 'hostname'
              }
            ];
            return _this.prompter(0);
          } else {
            return process.exit();
          }
        });
      } else if (this.options.remove_app) {
        process.stdin.resume();
        console.log("\n\nYou sure you want to remove the settings for the app " + this.options.appname + "?\n\ntype 'yes' or 'no'\n\n");
        process.stdin.once('data', function(input) {
          var config_str;
          if (input === 'yes\n') {
            delete _this.options.config_file[_this.options.appname];
            config_str = JSON.stringify(_this.options.config_file, null, 4);
            fs.writeFile('./config.json', config_str);
            return process.stdin.pause();
          } else {
            return process.exit();
          }
        });
      } else {
        this.push();
      }
    }

    Synk.prototype.prompter = function(i) {
      var _this = this;
      console.log(this.prompts[i].prompt);
      return process.stdin.once('data', function(input) {
        var cleaned_input;
        if (_this.prompts[i].resolve) {
          cleaned_input = path.resolve(input.replace('\n', ''));
        } else {
          cleaned_input = input.replace('\n', '');
        }
        _this.settings[_this.prompts[i].value] = cleaned_input;
        i++;
        if (i >= _this.prompts.length) {
          console.log('enter a command that should be run on the server after file upload has compleated, or press enter to skip this.\n');
          return _this.post_upload_command_prompter();
        } else {
          return _this.prompter(i);
        }
      });
    };

    Synk.prototype.post_upload_command_prompter = function() {
      var _this = this;
      return process.stdin.once('data', function(input) {
        var settings_str;
        input = input.replace('\n', '');
        if (input) {
          _this.settings.post_upload_command_sequence.push(input);
          console.log('enter another command to add run, or press enter to finish.');
          return _this.post_upload_command_prompter();
        } else {
          settings_str = JSON.stringify(_this.settings, null, 4);
          console.log("Here are your settings for " + _this.options.appname + ":\n");
          console.log("" + settings_str + "\n to go with them type 'yes'. To enter them again type 'no' \n\n");
          return process.stdin.on('data', function(input) {
            var config_str;
            if (input === 'no\n') {
              return process.exit();
            } else {
              process.stdin.pause();
              _this.options.config_file[_this.appname] = _this.settings;
              config_str = JSON.stringify(_this.options.config_file, null, 4);
              return fs.writeFile('./config.json', config_str);
            }
          });
        }
      });
    };

    Synk.prototype.push = function() {
      var app, command, scp,
        _this = this;
      app = this.options.config_file[this.options.appname];
      command = "rsync -zvr -e \"ssh -i " + app.pem + "\" " + app.src + " " + app.username + "@" + app.hostname + ":" + app.remote_dir;
      scp = exec(command, {
        stdio: 'ignore'
      }, function(err, stdout, stderr) {
        if (err) {
          console.log(err);
          return process.exit(1);
        } else {
          scp.kill();
          return _this.open_ssh();
        }
      });
      return scp.stdout.pipe(process.stdout);
    };

    Synk.prototype.open_ssh = function() {
      var app, command, index, ssh, _i, _j, _len, _len1, _ref, _ref1, _results;
      app = this.options.config_file[this.options.appname];
      console.log('file upload compleate\n');
      console.log('now attempting to run the following commands:\n');
      _ref = app.post_upload_command_sequence;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        command = _ref[_i];
        console.log(command + '\n');
      }
      ssh = exec("ssh -t -t -i " + app.pem + " " + app.username + "@" + app.hostname, function(err, stdout, stderr) {
        if (err) {
          console.log(err);
          return process.exit(1);
        } else {
          return console.log('done');
        }
      });
      _ref1 = app.post_upload_command_sequence;
      _results = [];
      for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
        command = _ref1[index];
        _results.push(ssh.stdin.write("" + command + "\n"));
      }
      return _results;
    };

    return Synk;

  })();

  options = {
    appname: process.argv[2],
    config_file: config
  };

  _ref = process.argv;
  for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
    arg = _ref[index];
    switch (arg) {
      case '-n':
      case '--new':
        options["new"] = true;
        break;
      case '-rm':
      case '--remove':
        options.remove_app = true;
        break;
      case '-h':
      case '--help':
        options.show_help = true;
        break;
      case '-cp':
      case '--show-config-path':
        options.show_config_path = true;
        break;
      case '-c':
      case '--config':
        options.show_config = true;
        break;
      case '-a':
      case '--apps':
        options.show_apps = true;
    }
  }

  if (options.show_config_path) {
    console.log(path.resolve('./conig.json'));
  } else if (options.show_config) {
    console.log(JSON.stringify(config, null, 4));
  } else if (options.show_apps) {
    for (appname in config) {
      conf = config[appname];
      console.log(appname);
    }
  } else if (options.show_help) {
    console.log("\n\n\nUsage: synk [appname] [OPTIONS]\n\nOptions:\n	--new, -n                Create configuration for [appname]\n	--remove, -rm            Remove the setings for [appname]\n	--show-config-path, -cp  Show abs path to push config file for editing app settings manually\n	--apps, -a               Show a list of apps that have been configured\n	--help, -h               Show this message\n\n\n");
  } else {
    synk = new Synk(options);
  }

}).call(this);
